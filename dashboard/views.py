from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db.models import Count, Sum, Q, F
from inventory.models import Product, Operation, DocumentStatus, ProductStock, StockMovement
from django.utils import timezone
from datetime import timedelta
from django.shortcuts import render
from django.contrib.auth.decorators import login_required

class DashboardKPIView(APIView):
    # permission_classes = [IsAuthenticated]

    def get(self, request):
        # 1. Total Products
        total_products = Product.objects.count()

        # 2. Low Stock Items (Global check - if total stock across all warehouses < min_stock)
        # This is a bit complex if min_stock is per product globally. 
        # Let's assume min_stock_level is global for the product.
        # We need to annotate total quantity first.
        low_stock_count = 0
        out_of_stock_count = 0
        
        products = Product.objects.annotate(total_qty=Sum('stocks__quantity'))
        for p in products:
            qty = p.total_qty or 0
            if qty == 0:
                out_of_stock_count += 1
            elif qty < p.min_stock_level:
                low_stock_count += 1

        # 3. Pending Operations
        pending_receipts = Operation.objects.filter(
            operation_type=Operation.Type.RECEIPT, 
            status__in=[DocumentStatus.DRAFT, DocumentStatus.WAITING, DocumentStatus.READY]
        ).count()

        pending_deliveries = Operation.objects.filter(
            operation_type=Operation.Type.DELIVERY, 
            status__in=[DocumentStatus.DRAFT, DocumentStatus.WAITING, DocumentStatus.READY]
        ).count()

        pending_transfers = Operation.objects.filter(
            operation_type=Operation.Type.TRANSFER, 
            status__in=[DocumentStatus.DRAFT, DocumentStatus.WAITING, DocumentStatus.READY]
        ).count()

        data = {
            'total_products': total_products,
            'low_stock_items': low_stock_count,
            'out_of_stock_items': out_of_stock_count,
            'pending_receipts': pending_receipts,
            'pending_deliveries': pending_deliveries,
            'pending_transfers': pending_transfers,
        }
        return Response(data)

class DashboardChartsView(APIView):
    def get(self, request):
        # 1. Stock Quantity by Category
        stock_by_category = Product.objects.values('category__name').annotate(
            total_qty=Sum('stocks__quantity')
        ).order_by('-total_qty')
        
        # 2. Top Movers (Most moved products in last 30 days)
        last_30_days = timezone.now() - timedelta(days=30)
        
        top_movers = StockMovement.objects.filter(
            timestamp__gte=last_30_days
        ).values('product__name').annotate(
            moves=Count('id'),
            total_qty=Sum('quantity')
        ).order_by('-total_qty')[:5]
        
        return Response({
            'stock_by_category': stock_by_category,
            'top_movers': top_movers
        })

@login_required
def dashboard_view(request):
    # 1. Total Products
    total_products = Product.objects.count()

    # 2. Low Stock Items
    low_stock_count = 0
    out_of_stock_count = 0
    low_stock_items = []
    
    # Annotate total quantity
    products = Product.objects.annotate(total_qty=Sum('stocks__quantity'))
    for p in products:
        qty = p.total_qty or 0
        if qty == 0:
            out_of_stock_count += 1
        elif qty <= p.min_stock_level:
            low_stock_count += 1
            # Add to list for table
            # We need to find the location for the alert, or just list the product
            # For simplicity, we'll just list the product and its total qty
            # But the template expects 'alert' objects with 'current_quantity' and 'threshold'
            # Or we can fetch actual LowStockAlert objects if they exist
            pass

    # Fetch actual LowStockAlerts for the table
    # Assuming LowStockAlerts are generated by a background task or signal
    # If not, we might need to generate them on the fly or just pass products
    # The template uses: {% for alert in low_stock_items %} ... alert.product.name ... alert.current_quantity
    from inventory.models import LowStockAlert
    low_stock_items = LowStockAlert.objects.filter(is_resolved=False).select_related('product', 'location')[:5]

    # 3. Pending Operations
    pending_receipts = Operation.objects.filter(
        operation_type=Operation.Type.RECEIPT, 
        status__in=[DocumentStatus.DRAFT, DocumentStatus.WAITING, DocumentStatus.READY]
    ).count()

    pending_deliveries = Operation.objects.filter(
        operation_type=Operation.Type.DELIVERY, 
        status__in=[DocumentStatus.DRAFT, DocumentStatus.WAITING, DocumentStatus.READY]
    ).count()

    # 4. Recent Activity
    recent_activity = []
    # Combine recent operations and stock movements?
    # Let's just use recent StockMovements
    recent_moves = StockMovement.objects.all().order_by('-timestamp')[:10]
    for move in recent_moves:
        recent_activity.append({
            'type': move.transaction_type.lower(), # 'receipt', 'delivery'
            'description': f"{move.product.sku} - {move.quantity} ({move.transaction_type})",
            'timestamp': move.timestamp
        })

    context = {
        'total_products': total_products,
        'low_stock_count': low_stock_count,
        'out_of_stock_count': out_of_stock_count,
        'pending_receipts': pending_receipts,
        'pending_deliveries': pending_deliveries,
        'low_stock_items': low_stock_items,
        'recent_activity': recent_activity,
    }
    return render(request, 'dashboard/index.html', context)
